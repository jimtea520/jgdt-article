RocketMQ可靠性保证

# 可靠性保证

## 生产者可靠性保证

消息生产者发送消息后返回SendResult，如果isSuccess返回为true,则表示消息已经确认发送到服务器并被服务器接收存储。整个发送过程是一个**同步**的过程。保证消息送达服务器并返回结果。返回发送失败，则需要业务方来考虑处理方式。

## broker可靠性保证

消息生产者发送的消息，meta服务器收到后在做必要的校验和检查之后的第一件事就是写入磁盘，写入成功之后返回应答给生产者。因此，可以确认每条发送结果为成功的消息服务器都是写入磁盘的。 写入磁盘，不意味着数据落到磁盘设备上，毕竟我们还隔着一层os，**os对写有缓冲**。Meta有以下刷盘策略：

异步刷盘：只要消息保存到Broker的内存就向发送者返回响应，Broker会有专门的线程对内存中的消息进行批量存储。所以异步刷盘的策略下，当机器突然掉电时，Broker内存中的消息因无法刷到磁盘导致丢失。
每1000条（可配置），即强制调用一次force来写入磁盘设备。
每隔10秒（可配置），强制调用一次force来写入磁盘设备。

同步刷盘：:同步刷盘是在每条消息都确认落盘了之后才向发送者返回响应
此外，如果存储配置上的groupCommitEnable选项为true，则会在写入消息后，立即强制刷盘。

## 消费者可靠性保证

消费者**顺序消费**，只有在成功消费一条消息后才会接着消费下一条。如果在消费某条消息失败（如异常），则会尝试重试消费这条消 息（默认最大5次），超过最大次数后仍然无法消费，则将**消息存储在消费者的本地磁盘，由后台线程继续做重试**。而主线程继续往后走，消费后续的消息。因此， 只有在MessageListener确认成功消费一条消息后，meta的消费者才会继续消费另一条消息。由此来保证消息的可靠消费。

消费者的另一个可靠性的关键点是**offset的存储**，也就是拉取数据的偏移量。默认存储在zoopkeeper上，zookeeper通过集群来保证数据的安全性。**Offset会定期保存**，并且在每次重新负载均衡前都会强制保存一次，因此可能会存在极端情况下的消息的重复消费。