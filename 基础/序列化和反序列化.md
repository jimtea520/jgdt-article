序列化和反序列化

# 简介



![image-20200813155953390](E:%5C%E6%8A%80%E6%9C%AF%E5%B8%96%E5%AD%90%5C%E7%AC%94%E8%AE%B0%5C%E5%9F%BA%E7%A1%80%5C%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%5C20200813155953.png)

## **对象的序列化**

如上图，我们把一个Person对象以流的方式，写入到文件中保存，叫写对象，也叫对象序列化，对象中包含的不仅仅是字符，使用字节流。

ObjectOutputStream：对象的序列化流

对象序列化的最主要的用处就是**在传递,和保存对象(object)的时候,保证对象的完整性和可传递性。**

## **对象的反序列**

把文件中保存的对象，以流的方式读取出来，叫做读取对象，也叫对象的反序列。读取的文件保存的都是字节，使用字节流。

ObjectInputStream:对象的反序列流

关于序列化与反序列化，其实就是将对象从文件中写入（序列化）或者是读取（反序列化），反序列化的时候，我们用Object类来接收，因为Object类可以接收任意对象。



## **序列化步骤**

**◆ 将对象实例相关的类元数据输出。**

**◆ 递归地输出类的超类描述直到不再有超类。**

**◆ 类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。**

**◆ 从上至下递归输出实例的数据**



## 实现序列化步骤

**1.声明对象具有可序列化的能力**

**2.通过Java API实现具体的序列化处理**



# 几个问题



## 什么情况下需要序列化?

a）**当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；**

**b）当你想用套接字在网络上传送对象的时候；**

**c）当你想通过RMI传输对象的时候；**



## 当对一个对象实现序列化时，究竟发生了什么？

在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）



# 相关注意事项



a）序列化时，只对对象的状态进行保存，而不管对象的方法；

b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；

c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；

d）并非所有的对象都可以序列化，至于为什么不可以，有很多原因了,比如：

1、安全方面的原因

比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。

2、资源分配方面的原因

比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。

声明为**static和transient**类型的成员数据不能被序列化。因为static代表类的状态，transient代表**对象的临时数据**。



# 序列化和外部化的主要区别

**序列化会自动存储必要的信息，用以反序列化被存储的实例**，而外部化则**只保存被存储的类的标识。**当你通过java.io.serializable接口 序列化一个对象时，**有关类的信息，比如它的属性和这些属性的类型，都与实例数据一起被存储起来。**在选择走externalizable这条路时，java **只存储有关每个被存储类型的非常少的信息。**

每个接口的优点和缺点

## 序列化

### 优点：

1、内建支持

2、易于实现

### 缺点：

1、占用空间过大

2、由于额外的开销导致速度变比较慢

## 外部化

### 优点：

1、开销较少（程序员决定存储什么）

2、可能的速度提升

### 缺点：

虚拟机不提供任何帮助，也就是说所有的工作都落到了开发人员的肩上。