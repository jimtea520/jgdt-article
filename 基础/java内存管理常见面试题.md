## java内存管理常见面试题

### “用Java管理内存”的含义是什么意思？

内存是应用程序有效运行所需的关键资源，就像任何资源一样，它很少。因此，它在应用程序或应用程序的不同部分之间的分配和释放需要非常小心和考虑。

但是，在Java中，开发人员不需要显式分配和释放内存--JVM，更具体地说是垃圾收集器 - 有责任处理内存分配，以便开发人员不必这样做。

这与C语言中的情况相反，在C语言中，程序员可以直接访问内存并在代码中引用内存单元，从而为内存泄漏创造了大量空间。

### 什么是垃圾收集？它的优点是什么？

垃圾收集是查看堆内存，识别正在使用哪些对象以及哪些对象未使用的过程，以及删除未使用的对象。

正在使用的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。因此可以回收未引用对象使用的内存。

垃圾收集的最大优点是它消除了我们手动内存分配/释放的负担，因此我们可以专注于解决手头的问题。

###  垃圾收集有什么缺点吗？

有。每当垃圾收集器运行时，它都会影响应用程序的性能。这是因为必须停止应用程序中的所有其他线程以允许垃圾收集器线程有效地执行其工作。

根据应用程序的要求，这可能是客户无法接受的真正问题。但是，通过熟练的优化和垃圾收集器调整以及使用不同的GC算法，可以大大减少甚至消除这个问题。

###  “stop-the-world”一词的含义是什么？

当垃圾收集器线程正在运行时，其他线程将停止，这意味着应用程序暂时停止。这类似于房屋清洁，在此过程完成之前，居住者将被拒绝进入。

根据应用程序的需要，“stop-the-world”垃圾收集可能导致不可接受的冻结。这就是为什么重要的是进行垃圾收集器调整和JVM优化，以便遇到的冻结至少是可以接受的。

### 什么是堆栈和堆？存储在每个存储器结构中的内容以及它们如何相互关联？

堆栈是内存的一部分，包含有关嵌套方法调用的信息，直到程序中的当前位置。它还包含所有局部变量和对当前正在执行的方法中定义的堆上的对象的引用。

此结构允许运行时从知道调用地址的方法返回，并在退出方法后清除所有局部变量。每个线程都有自己的堆栈。

堆是用于分配对象的大量内存。使用new关键字创建对象时，它将在堆上分配。但是，对该对象的引用存在于堆栈中。

### 什么是分代垃圾收集，是什么使它成为一种流行的垃圾收集方法？

分代垃圾收集可以松散地定义为垃圾收集器使用的策略，其中堆被分成许多称为代的部分，每个部分将根据堆上的“年龄”来保存对象。

每当垃圾收集器运行时，该过程的第一步称为标记。这是垃圾收集器识别正在使用哪些内存而哪些内存不在使用的地方。如果必须扫描系统中的所有对象，则这可能是非常耗时的过程。

随着越来越多的对象被分配，对象列表会增长和增长，从而导致垃圾收集时间越来越长。然而，对应用程序的实证分析表明，大多数对象都是短暂的。

对于分代垃圾收集，对象根据它们的“年龄”按其存活的垃圾收集周期数进行分组。这样，大部分工作分散在各种次要和主要的收集周期中。

今天，几乎所有垃圾收集者都是世代相传的。这种策略非常受欢迎，因为随着时间的推移，它已被证明是最佳解决方案。

### 详细描述分代垃圾收集的工作原理

要正确理解分代垃圾收集的工作原理，首先要记住如何构建Java堆以促进分代垃圾收集。

堆被分成更小的空间或代。这些空间是年轻代，老代或终身代，以及永久代。

在年轻代的主机大部分新创建的对象的。对大多数应用程序的实证研究表明，大多数对象很快就会短暂存在，因此很快就有资格收集。因此，新物体在这里开始他们的旅程，并且在他们达到某个“年龄”之后才被“提升”到老代的空间。

分代垃圾收集中的术语“年龄” 是指对象存活的收集周期数。

年轻代空间进一步分为三个空间：Eden空间和两个幸存者空间，如幸存者1（s1）和幸存者2（s2）。

在老代主机的对象 不再住在内存中超过一定的“年龄”。从年轻代中收集垃圾的幸存物体被提升到这个空间。它通常比年轻代更大。由于它的尺寸更大，垃圾收集更昂贵，并且发生频率低于年轻代。

永久代或更通常称为PermGen，包含由JVM所需的元数据来描述应用程序使用的类和方法。它还包含用于存储实习字符串的字符串池。它在运行时由JVM根据应用程序使用的类填充。此外，平台库类和方法可以存储在这里。

首先，任何新对象都分配给Eden空间。两个幸存者空间都是空的。当Eden空间填满时，会触发一个小的垃圾收集。引用的对象被移动到第一个幸存者空间。删除未引用的对象。

在下一个次要GC期间，Eden空间也会发生同样的事情。删除未引用的对象，并将引用的对象移动到幸存者空间。然而，在这种情况下，它们被移动到第二幸存空间（S2）。

此外，来自第一个幸存者空间（S1）中的最后一个小GC的对象的年龄增加并且移动到S2。一旦所有幸存的物体都移动到S2，S1和Eden空间都被清除。此时，S2包含具有不同年龄的对象。

在下一个次要GC中，重复相同的过程。然而这次幸存者空间切换。引用的对象从Eden和S2移动到S1。幸存的物体会老化。Eden和S2被清除。

在每个次要垃圾收集周期之后，检查每个对象的年龄。那些已经达到某个任意年龄的人，例如8岁，从年轻一代晋升到老一代或终身一代。对于所有后续次要GC循环，对象将继续提升到旧代空间。

这几乎耗尽了年轻一代的垃圾收集过程。最终，将对老代进行重大垃圾收集，清理并压缩该空间。对于每个主要的GC，有几个小的GC。

### 对象什么时候有资格进行垃圾回收？描述GC如何收集符合条件的对象？

如果无法从任何活动线程或任何静态引用访问对象，则该对象符合垃圾收集或GC的条件。

对象变得有资格进行垃圾收集的最直接的情况是它的所有引用都是null。没有任何实时外部引用的循环依赖项也适用于GC。因此，如果对象A引用对象B而对象B引用对象A并且它们没有任何其他实时引用，则对象A和B都将有资格进行垃圾收集。

另一个明显的情况是父对象设置为null。当厨房对象在内部引用冰箱对象和水槽对象，并且厨房对象设置为空时，冰箱和水槽都将有资格与其父对象，厨房一起进行垃圾收集。

### 如何从Java代码中触发垃圾收集？

作为Java程序员，您无法在Java中强制进行垃圾收集 ; 它只会在JVM认为需要基于Java堆大小的垃圾收集时触发。

在从内存中删除对象之前，垃圾收集线程调用该对象的finalize（）方法，并提供执行所需的任何类型清理的机会。您也可以调用此对象代码方法，但是，无法保证在调用此方法时将发生垃圾回收。

此外，还有一些方法，如System.gc（）和Runtime.gc（），用于将垃圾收集请求发送到JVM，但不保证垃圾收集会发生。

### 当没有足够的堆空间来容纳新对象的存储时会发生什么？

如果没有用于在Heap中创建新对象的内存空间，Java虚拟机会抛出OutOfMemoryError或更具体地抛出java.lang.OutOfMemoryError堆空间。

### 是否有可能“复活”一个符合垃圾收集条件的对象？

当一个对象符合垃圾收集条件时，GC必须在其上运行finalize方法。在敲定方法是保证只运行一次，因此GC标志的对象定稿，并给它休息，直到下一个周期。

在finalize方法中，您可以在技术上“复活”对象，例如，通过将其指定给静态字段。该对象将再次变为活动状态且不符合垃圾收集条件，因此GC不会在下一个循环中收集它。

但是，该对象将被标记为已完成，因此当它再次符合条件时，将不会调用finalize方法。从本质上讲，你可以在对象的生命周期中只转换一次“复活”技巧。请注意，只有当你真正知道自己在做什么时才应该使用这个丑陋的黑客 - 然而，理解这个技巧可以让你深入了解GC的工作原理。

### 描述强，弱，软和虚拟引用及其在垃圾收集中的作用。

就像在Java中管理内存一样，工程师可能需要在关键应用程序中执行尽可能多的优化以最小化延迟并最大化吞吐量。因为无法显式控制何时在JVM中触发垃圾收集，所以可能会影响我们创建的对象的发生方式。

Java为我们提供了引用对象来控制我们创建的对象和垃圾收集器之间的关系。

默认情况下，我们在Java程序中创建的每个对象都由变量强引用：

```cpp
StringBuilder sb = new StringBuilder();
```

在上面的代码片段中，new关键字创建一个新的StringBuilder对象并将其存储在堆上。变量sb然后存储对该对象的强引用。这对于垃圾收集器来说意味着特定的StringBuilder对象完全没有资格进行收集，因为sb对它进行了强大的引用。只有在我们这样取消sb时，故事才会改变：

```java
sb = null;
```

调用上面的行后，该对象将有资格进行收集。

我们可以通过将它显式地包装在位于java.lang.ref包内的另一个引用对象中来改变对象和垃圾收集器之间的这种关系。

可以为上述对象创建一个软引用，如下所示：

```java
StringBuilder sb = new StringBuilder();
SoftReference<StringBuilder> sbRef = new SoftReference<>(sb);
sb = null;
```

在上面的代码片段中，我们创建了两个StringBuilder对象的引用。第一行创建一个强引用 sb，第二行创建一个软引用 sbRef。第三行应该使对象有资格收集，但垃圾收集器将推迟收集它，因为sbRef。

只有当内存变得紧张且JVM处于抛出OutOfMemory错误的边缘时，故事才会改变。换句话说，仅收集具有软引用的对象作为恢复内存的最后手段。

甲弱引用可以使用类似的方式来创建的WeakReference类。当sb设置为null并且StringBuilder对象只有弱引用时，JVM的垃圾收集器绝对没有妥协，并在下一个周期立即收集对象。

虚拟引用参考类似于弱引用，并用仅虚引用的对象将无需等待被收集。但是，只要收集了对象，就会将幻像引用排入队列。我们可以轮询引用队列以确切知道何时收集对象。

### 假设我们有一个循环引用（两个相互引用的对象）。这样的对象是否有资格进行垃圾收集？为什么？

是的，具有循环引用的一对对象可以有资格进行垃圾回收。这是因为Java的垃圾收集器处理循环引用。它认为对象不是在它们有任何引用时生存，而是通过从一些垃圾收集根（实时线程的局部变量或静态字段）开始导航对象图来实现它们。如果无法从任何根访问具有循环引用的一对对象，则认为它有资格进行垃圾回收。

###  字符串如何在内存中表示？

该字符串在Java实例是具有两个字段的对象：一个字符[]值字段和INT散列字段。的值字段是表示字符串本身字符数组，并且散列字段包含的hashCode其被初始化为零，所述第一期间计算一个字符串的hashCode（）方法自从呼叫和高速缓存。作为一个奇怪的边缘情况，如果字符串的hashCode具有零值，则每次调用hashCode（）时都必须重新计算它。

重要的是String实例是不可变的：您无法获取或修改底层char []数组。字符串的另一个特性是静态常量字符串被加载并缓存在字符串池中。如果源代码中有多个相同的String对象，则它们在运行时都由单个实例表示。

### 什么是StringBuilder以及它的用例是什么？将字符串附加到StringBuilder并将两个字符串与+运算符连接之间有什么区别？如何StringBuilder的从不同的StringBuffer？

StringBuilder允许通过附加，删除和插入字符和字符串来操作字符序列。这是一个可变数据结构，而不是String类，它是不可变的。

连接两个String实例时，会创建一个新对象，并复制字符串。如果我们需要在循环中创建或修改字符串，这可能会带来巨大的垃圾收集器开销。StringBuilder允许更有效地处理字符串操作。

StringBuffer的是从不同的StringBuilder，它是线程安全的。如果需要在单个线程中操作字符串，请改用StringBuilder。