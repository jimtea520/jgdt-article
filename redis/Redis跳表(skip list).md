跳跃表(skip list)



## **为什么选择跳表**

目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。

 

想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树

出来吗？ 很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的树，

还要参考网上的代码，相当麻烦。

 

用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，

它的效率和红黑树以及 AVL 树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，

就能轻松实现一个 SkipList。

 

## 有序表的搜索

考虑一个有序表：


![image-20200925102209090](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102209.png)

 

从该有序表中搜索元素 < 23, 43, 59 > ，需要比较的次数分别为 < 2, 4, 6 >，总共比较的次数

为 2 + 4 + 6 = 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉

搜索树，我们把一些节点提取出来，作为索引。得到如下结构：


![image-20200925102237407](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102237.png)


 这里我们把 < 14, 34, 50, 72 > 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。

 我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：

 

![image-20200925102252538](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102252.png)

 

   这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。

 

## 跳表

下面的结构是就是跳表：

 其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。

 

![image-20200925102311756](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102312.png)

 

跳表具有如下性质：

(1) 由很多层结构组成

(2) 每一层都是一个有序的链表

(3) 最底层(Level 1)的链表包含所有元素

(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。

(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

 

## 跳表的搜索


![image-20200925102331441](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102331.png)

 

例子：查找元素 117

(1) 比较 21， 比 21 大，往后面找

(2) 比较 37,  比 37大，比链表最大值小，从 37 的下面一层开始找

(3) 比较 71,  比 71 大，比链表最大值小，从 71 的下面一层开始找

(4) 比较 85， 比 85 大，从后面找

(5) 比较 117， 等于 117， 找到了节点。

 

具体的搜索算法如下： 

```
/* 如果存在 x, 返回 x 所在的节点， 

否则返回 x 的后继节点 */  
find(x)   
{  
 p = top;  
 while (1) {  
     while (p->next->key < x)  
         p = p->next;  
     if (p->down == NULL)   
         return p->next;  
     p = p->down;  
 }  
}  
```



## 跳表的插入

先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）

然后在 Level 1 ... Level K 各个层的链表都插入元素。

例子：插入 119， K = 2

![image-20200925102402632](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102402.png)

如果 K 大于链表的层数，则要添加新的层。

例子：插入 119， K = 4

![image-20200925102513077](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102513.png)

## 丢硬币决定 K

插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：

```
int random_level()  
{  
    K = 1;  

while (random(0,1))  
    K++;  

return K;  

}
```

相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，

用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，

K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。

 

 

## 跳表的高度。

n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，

跳表的高度等于这 n 次实验中产生的最大 K，待续。。。



## **时间复杂度的分析**

如果每两个节点抽出一个节点作为上一级索引的节点，那第一级索引的节点个数大约就是 `n/2` ,第二级索引是 `n/4`, 第三级就是 `n/8`。 也就是说 第 `k` 级索引节点个数是 `n/(2^k)`;

假设,我们有 `h` 层, 最高层索引有`2`个节点,那么， 就是 `n/(2^k)=2`, 那么 ![image-20200925155003739](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925155003.png)，这个链表的高度就是 ![image-20200925155032617](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925155032.png). 如果每一层要遍历 `m` 个节点,那么在跳表中查询一个数据的时间复杂度就是`O(m*logN)`.

由于随机分布的存在，我们可以把m当做一个常数, 所以, 时间复杂度大致可以认为是 `O(logN)`



## 跳表的空间复杂度分析

根据整体代码实现来看, 我们使用了链表的形式来实现. 其中，`next` 改成了数组用来存储下一节点的指针,并没有真正的存储对象,. 也就是说,其实我们并没有使用很多的内存, 当然，比一般的链表还是要多一些的。对于我们存储的对象来讲，用于存储指针的内存直接就可以忽略了。时间复杂度为 `O(N+m)`,其中 `N>>m`(`N`远远大于`m`).

根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的

期望值是 2n。

 

## 跳表的删除

在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。

例子：删除 71



![image-20200925102623349](https://gitee.com/fking86/images4typora/raw/master/imgs/20200925102623.png)





### **跳表 与平衡树、哈希表的比较**



|                  |      跳表       |                  平衡树                  |    哈希表    |
| :--------------: | :-------------: | :--------------------------------------: | :----------: |
|      有序性      |      有序       |                   有序                   |     无序     |
|     查找新能     |    O（logN）    |                O（logN）                 |    O（1）    |
|     实现逻辑     |      简单       |                   复杂                   |     简单     |
| 是否支持范围查找 |      支持       |                   支持                   | 不支持(无序) |
|    时间复杂度    | 较少，取决P参数 | 较大（和跳表比，占用左右字数的两个指针） |     一般     |



### **解释如下:**

- 在做范围查找的时候，平衡树比跳表操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第`1`层链表进行若干步的遍历就可以实现。
- 平衡树的增删操作可能引发子树的平衡调整，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。
- 从内存占用上来说，跳表比平衡树更灵活一些。一般来说，平衡树每个节点包含`2`个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为`1/(1-p)`，具体取决于参数`p`的大小。如果像`Redis`里的实现一样，取`p=1/4`，那么平均每个节点包含`1.33`个指针，比平衡树更有优势。
- 查找单个`key`，跳表和平衡树的时间复杂度都为`O(log n)`，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近`O(1)`，性能更高一些。

